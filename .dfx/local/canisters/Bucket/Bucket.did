type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback:
                               func (CallbackToken) ->
                                (StreamingCallbackHttpResponse) query;
                              token: CallbackToken;
                            };};
type StreamingCallbackHttpResponse__1 = 
 record {
   body: blob;
   token: opt CallbackToken;
 };
type StreamingCallbackHttpResponse = 
 record {
   body: blob;
   token: opt CallbackToken;
 };
type StreamingCallback = func (CallbackToken__1) ->
                          (StreamingCallbackHttpResponse__1) query;
type Result_1 = 
 variant {
   err: DataErr;
   ok: blob;
 };
type Result = 
 variant {
   err: DataErr;
   ok: AssetExt;
 };
type PUT = 
 record {
   chunk: Chunk;
   chunk_number: nat;
   chunk_order: nat;
   file_extension: text;
   file_key: text;
   file_name: text;
   total_size: nat;
 };
type HttpResponse = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type HttpRequest = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type GET = 
 record {
   file_key: text;
   flag: nat;
 };
type DataErr = 
 variant {
   BlobSizeError;
   FileKeyErr;
   FlagErr;
   MemoryInsufficient;
 };
type Chunk = 
 record {
   data: blob;
   digest: vec nat8;
 };
type CallbackToken__1 = 
 record {
   index: nat;
   key: text;
   max_index: nat;
 };
type CallbackToken = 
 record {
   index: nat;
   key: text;
   max_index: nat;
 };
type AssetExt = 
 record {
   bucket_id: principal;
   file_extension: text;
   file_key: text;
   file_name: text;
   need_query_times: nat;
   total_size: nat;
   upload_status: bool;
 };
service : {
  build_http: (StreamingCallback) -> ();
  get: (GET) -> (Result_1) query;
  http_request: (HttpRequest) -> (HttpResponse) query;
  put: (PUT, principal) -> (Result);
}
